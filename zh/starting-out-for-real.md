# 真·初探

Erlang是一种相对较小且简单的语言（是"C比C++更简单"的那种简单）。该语言中有一些基本的数据类型，因此，本章将介绍其中的大部分。强烈建议阅读它，因为它解释了您稍后将使用Erlang编写的所有程序的构建块。

## [数字](#numbers)

在Erlang shell中，**表达式必须以句点结尾，后跟空格（换行符、空格等）**，否则他们不会被执行。可以用逗号分隔表达式，但只显示最后一个表达式的结果（其他表达式仍在执行）。这对大多数人来说肯定是不寻常的语法，这是因为Erlang最初是在逻辑编程语言Prolog中实现的。

打开Erlang shell并输入下列语句：

```shell
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472.
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
```

![A calculator with the number '80085' typed in](../img/calculator.png "tee hee")

您应该注意到，Erlang并不关心是否输入浮点数或整数：在处理算术运算时，这两种类型都受支持。整数和浮点值几乎是Erlang的数学运算符为您透明处理的唯一数据类型。但是，如果要进行整数到整数的除法，请使用`div`，要进行模运算，请使用`rem`（余数）。

注意，在一个数学表达式中，我们可以使用几个正常的优先级运算符。

```shell
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
```

如果你想用除基数10以外的其他基数来表示整数，只需输入`base#Value`（Base需要在2~36的范围内）:

```shell
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
```

很棒对吧？Erlang具有你桌上那个卡西欧所有的功能，只是语法比较奇怪。

## [不可变变量](#invariable-variables)

Erlang可以做算术，但如果你不能将结果存储在某个地方，你就不会走得太远。为此，我们将使用变量。如果你读过这本书的介绍，你就会知道变量在函数式编程中是不可变的。变量的基本行为可以通过以下7个表达式来演示（注意，变量以大写字母开头）：

```shell
1> One.
* 1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.        
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
```

这些命令告诉我们的第一件事是，你只可以给变量赋值一次；然后你可以“假装”给一个变量赋值，如果它已经有了相同的值。如果值不同，Erlang会报错。这是一个正确的观察结果，但解释其原因有点复杂，这实际是由`=`运算符决定的。`=`运算符（不是变量）的作用是比较值，并在值不同时报错。如果它们相同，则返回值：

```shell
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
```

当与变量混合时，该运算符的作用是，如果左侧项是一个变量且未绑定（没有与之关联的值），Erlang将自动将右侧值绑定到左侧的变量。因此，比较将成功，变量将在内存中保留该值。

`=`运算符的这种行为是“模式匹配”的基础，许多函数式编程语言都有“模式匹配”，尽管Erlang的处理方式通常被认为比其他方法更灵活、更完整。当我们在这一章中讨论元组和列表类型，以及在后续章节讨论函数时，我们将看到模式匹配的更多细节。

命令1-7告诉我们的另一件事是变量名必须以大写字母开头。命令7失败，因为单词'two'以小写字母开头。从技术上讲，变量也可以以下划线（`_`）开头，但按照惯例，它仅限于您不关心该值，但您觉得有必要记录它包含的内容时使用。

你也可以仅仅使用下划线来定义变量：

```shell
10> _ = 14+3.
17
11> _.
* 1: variable '_' is unbound
```

与任何其他类型的变量不同，它永远不会存储任何值。这听上去完全没有用，但当我们需要它时，你会知道它的存在。

> **注意：** 如果在shell中进行测试，并将错误的值保存到变量中，则可以使用函数`f（variable）`来“擦除”该变量。如果希望清除所有变量名，请执行`f（）`。
这些函数只在测试时提供帮助，并且只能在shell中工作。在编写真正的程序时，我们无法以这种方式清除变量。之所以要限制这个功能仅用于shell，是由于Erlang被使用在生产环境中：其中的一些shell完全有可能在数年内不间断地处于活动状态，其中多半会有个变量`X`在那个时间段内被多次使用……

## [原子](#atoms)

There is a reason why variables names can't begin with a lowercase character: atoms. Atoms are literals, constants with their own name for value. What you see is what you get and don't expect more. The atom `cat`. Deal with it.
变量名不能以小写字母开头是有原因的：原子（atoms）。原子通常是文字，常数，它们的名字就是它们的值。你看到的就是你得到的，不要期待更多。原子`cat`, 就是这样[^1]。

除了以小写字母开头的单词来命名atom，还有多种方式：

```shell
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated!'.
'Atoms can be cheated!'
5> atom = 'atom'.
atom
```

如果原子不是以小写字母开头，或者包含字母数字字符、下划线（`_`）, `@`或其他字符，则应将其括在单引号（`'`）中。表达式5还表明，带有单引号的原子与没有单引号的类似原子完全相同。

![An Atom, as imagined by Rutherford](../img/atom.png) (Modules)。
我将原子与以其名称作为其值的常数进行比较。您以前可能使用过使用常量的代码：例如，假设我有眼睛颜色的值：`蓝色->1，棕色->2，绿色->3，其他->4`。您需要将常量的名称与某个（隐藏的）基础值相匹配。原子让你避免了这种基础值：我的眼睛颜色可以是`蓝色`、`棕色`、`绿色`和`其他`。这些颜色可以在任何代码中的任何地方使用：基础值永远不会冲突，并且不可能不定义这样的常量！如果您真的希望常量具有与之关联的基础值，那么有一种方法可以做到这一点，我们将在第4章[模块](modules.md)中看到。

原子主要用于表示或限定与其耦合的数据。很难找到好的单独使用的方法。这就是为什么我们不会花更多时间去研究它们；当与其他类型的数据结合使用时，它们将得到最佳利用。

> **不要削足适履:**
原子真的很好，是发送信息或表示常数的好方法。然而，在太多事情上使用原子也有缺陷：原子在消耗内存的`原子表`中被引用（32位系统中为4字节/原子，64位系统中为8字节/原子）。atom表不会被垃圾收集的，因此原子将累积，直到系统提示结束，这可能是因为内存使用情况，也可能是因为声明了1048577个原子。
这意味着无论出于何种原因，原子都不应该动态生成；如果用户的输入可以让系统产生原子从而来随意破坏它，那么这个系统就不是可靠的。原子应该被视为专用于开发人员的工具，因为老实说，原子就是这样设计的。

**注：** 有些原子是保留字，不能使用，除非语言设计者希望它们被使用，例如：函数名、运算符、表达式等。这些是：
`after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor`

## [布尔代数与比较符](#bool-and-compare)

![George Boole](../img/boole.png "Sup baby, would you like to go Booling?")

如果一个人不能分辨出什么是小的和大的，什么是真的和假的，那么他就会陷入相当大的麻烦之中。与其他任何语言一样，Erlang也可以让您使用布尔操作符并比较项:

```shell
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
```

**注：**布尔运算符`and`和`or`将始终计算运算符两侧的参数。如果希望使用短路运算符（即如果需要，只会计算右侧参数），请使用`andalso`和`orelse`。

相等或不相等的测试也非常简单，但符号与许多其他语言中的符号略有不同：

```shell
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0. 
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
```

首先，如果你熟悉的编程语言使用`==`和`!=`为了测试是否相等，Erlang使用`=:=`和`=/=`。最后三个表达式（第9行到第11行）也给我们带来了一个陷阱：Erlang不关心算术中的浮点数和整数，但在比较它们时会这样做。不过不用担心，因为`==`和`/=`运算符在这些情况下会帮助您。记住你是否想要比较完全的相等，这非常重要。

其他比较运算符还有`<`（小于）、`>`（大于）、`>=`（大于或等于）和`=<`（小于或等于）。最后一个是向后的（在我看来），是我代码中许多语法错误的根源。注意`=<`。

```shell
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
```

What happens when doing `5 + llama` or `5 == true`? There's no better way to know than trying it and subsequently getting scared by error messages!
当比较`5 + llama`或`5 == true`时会发生什么？没有比尝试它然后被错误消息吓到更好的方法了！

```shell
12> 5 + llama.
** exception error: bad argument in an arithmetic expression
     in operator  +/2
        called as 5 + llama
```

好啊！Erlang真的不喜欢你滥用它的一些基本类型！模拟器在这里返回了一条很好的错误消息。它告诉我们它不喜欢围绕`+`运算符使用的两个参数之一！

不过，Erlang也不一定总会因为错误的类型就冲你发火：

```shell
13> 5 =:= true.
false
```

为什么它在某些操作中拒绝不同的类型，而在其他操作中不拒绝？虽然Erlang不允许你*添加*任何东西，但它可以让你对它们进行*比较*。这是因为Erlang的创造者认为实用主义优于理论，并决定能够简单地编写一些东西，比如可以对任意项进行排序的通用排序算法它能让你的生活变得更简单，并且在大多数情况下都能做到。

在进行布尔运算和比较时要记住的最后一件事：

```shell
14> 0 == false.
false
15> 1 < false.
true
```

如果你来自过程式语言或大多数面向对象的语言，那么你很可能要抓狂了。第14行应该评估为`true`！毕竟，`false`意味着0，`true`意味着其他一切！除了在Erlang。这是因为我骗了你，哈哈，是的。

Erlang里根本就没有布尔`true`这样的东西。`true`和`false`这两个词是原子，但它们已经很好地融入了语言中，只要你不认为`false`和`true`是假和真以外的任何意思，你应该就不会碰到问题。

> **注:** 不同的元素在比较中会按如下顺序排序：`number < atom < reference < fun < port < pid < tuple < list < bit string` 。
你还不知道所有这些类型的事情，但你会通过这本书了解它们。记住，这就是为什么你可以将任何东西与任何东西进行比较！引用Erlang的创始人之一乔·阿姆斯特朗的话："实际的顺序并不重要，但总的顺序是明确定义的，这一点很重要。"。

## [元组](#tuples)

元组是一种组织数据的方法。如果你知道有多少个项，那元组就可以帮你将这些项组合起来。在Erlang中，元组是以`{Element1, Element2, ..., ElementN}`来表示的。举个例子，如果你想告诉我笛卡尔图中一个点的位置，你可以给我坐标（x，y）。我们可以将这一点表示为两个项的元组：

```shell
1> X = 10, Y = 4.
4
2> Point = {X,Y}.
{10,4}

```

在这种情况下，一个点总是包含两个项。如何提取变量'X'的坐标？提取这些信息并不难。记住，当我们赋值时，如果值相同，Erlang永远不会报错。让我们利用这一点！您可能需要用`f（）`来清理我们之前设置的变量。

```shell
3> Point = {4,5}.
{4,5}
4> {X,Y} = Point.
{4,5}
5> X.
4
6> {X,_} = Point.
{4,5}
```

这样我们就可以使用'X'了！这是模式匹配的多种形式之一。
![Mr. Brackets](../img/mr-brackets.png)

请注意，在表达式6中，我使用了匿名变量`_`，它总是被视为未绑定的，并充当模式匹配的通配符。这是因为模式匹配只有在元素数（元组的长度）相同的情况下，才能解包元组。

```shell
7> {_,_} = {4,5}.
{4,5}
8> {_,_} = {4,5,6}.
** exception error: no match of right hand side value {4,5,6}
```

元组在处理单个值时也很有用。例如这个处理温度的例子：

```shell
9> Temperature = 23.213.
23.213
```

听起来是去海滩的好日子……等等，这个温度是开尔文，摄氏度还是华氏度？

```shell
10> PreciseTemperature = {celsius, 23.213}.
{celsius,23.213}
11> {kelvin, T} = PreciseTemperature.
** exception error: no match of right hand side value {celsius,23.213}
```

这会抛出一个错误，但这正是我们想要的！这也是模式匹配在起作用。`=`操作符在比较`{kelvin, T}`和`{celsius, 23.213}`时，虽然变量`T`没有绑定，Erlang也不会将原子`celsius`认为和原子`kelvin`一致。这导致解释器抛出了一个异常，停止代码的执行。通过这样做，我们的程序中预期温度为开尔文的部分将无法处理以摄氏度发送的温度。这使得程序员更容易知道发送的是什么，也可以作为调试辅助工具。包含一个原子，其后有一个元素的一个元组被称为“标记元组（tagged tuple）”。元组的元素都可以是任何类型的，甚至是另一个元组：

```shell
12> {point, {X,Y}}.
{point,{4,5}}

```

那如果我们想要存储多个点呢？

## [列表](#lists)

列表是许多函数式语言的基本组成部分。它们用于解决各种问题，无疑是Erlang中使用最多的数据结构。列表可以包含任何内容！数字、原子、元组和其他列表；所有你最疯狂的梦想都可以被包含在这一个结构里。列表的基本符号是`[Element1，Element2，。。。，ElementN]`，您可以在其中混合多种类型的数据：

```shell
1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
```

很简单，对吧？

```shell
2> [97, 98, 99].
"abc"
```

哦！这是Erlang中最不喜欢的东西之一：字符串！字符串是列表，而且符号完全相同！为什么人们不喜欢它？因此：

```shell
3> [97,98,99,4,5,6].
[97,98,99,4,5,6]
4> [233].
"é"
```

只有当其中至少一个数字不能代表字母时，Erlang才会将数字列表打印为数字！在Erlang中没有真正的字符串！毫无疑问，这会在未来困扰你，你会因此而讨厌这种语言。不要绝望，因为还有其他写字符串的方法，我们将在本章后面看到。

> **不要削足适履:**
> 这就是为什么你可能听说Erlang在字符串操作方面很差劲：没有像大多数其他语言那样的内置字符串类型。这是因为Erlang起源于电信公司创造和使用的一种语言。他们从不（或很少）使用字符串，因此，从来没有正式添加过字符串。然而，Erlang在字符串操作方面缺少的功能随着时间的推移而逐渐得到修复：VM现在本机支持Unicode字符串，而且总体而言，字符串操作的速度一直在加快。
> 还有一种方法可以将字符串存储为二进制数据结构，从而使它们更加轻巧，处理起来更快。总而言之，标准库中仍然缺少一些函数，虽然字符串处理在Erlang中是绝对可行的，但对于需要大量字符串处理的任务，有一些更好的语言，比如Perl或Python。

要将列表粘合在一起，我们使用`++`操作符。`++`的反面是`--`，它将从列表中删除元素：

```shell
5> [1,2,3] ++ [4,5].
[1,2,3,4,5]
6> [1,2,3,4,5] -- [1,2,3].
[4,5]
7> [2,4,2] -- [2,4].
[2]
8> [2,4,2] -- [2,4,2].
[]
```

`++`和`--`都是右关联的（right-associative）。这意味着许多`--`或`++`操作的元素将从右向左执行：

```shell
9> [1,2,3] -- [1,2] -- [3].
[3]
10> [1,2,3] -- [1,2] -- [2].
[2,3]
```

让我们继续。列表的第一个元素名为头部（Head），其余元素名为尾部（Tail）。我们将使用两个内置函数（built-in functions, BIF）来获取它们。

```shell
11> hd([1,2,3,4]).
1
12> tl([1,2,3,4]).
[2,3,4]
```

> **注：** 内置函数（BIFs）通常是无法使用Erlang实现，因而使用C或者别的什么语言（例如80年代的Prolog）来实现的。有一些内置函数虽然可以使用Erlang实现，但因为较为普遍，而采用了C来实现以便达到更快的执行速度。其中一个例子是`length（List）`函数，它将返回作为参数传入的列表的长度。

Accessing or adding the head is fast and efficient: virtually all applications where you need to deal with lists will always operate on the head first. As it's used so frequently, there is a nicer way to separate the head from the tail of a list with the help of pattern matching: `[Head|Tail]`. Here's how you would add a new head to a list:
访问或添加head既快速又高效：几乎所有需要处理列表的应用程序都会首先在head上运行。由于它被频繁使用，有一种更好的方法可以通过模式匹配来分割列表的头部和尾部：`[Head|Tail]`。以下是如何在列表中添加新head：

```shell
13> List = [2,3,4].
[2,3,4]
14> NewList = [1|List].
[1,2,3,4]
```

在处理列表时，通常从头部开始，您需要一种快速的方法来存储尾部，以便以后对其进行操作。如果您还记得元组的工作方式，以及我们如何使用模式匹配来解压缩点`({X,Y})`的值，您就会知道我们可以以类似的方式从列表中切掉第一个元素（头部）。

```shell
15> [Head|Tail] = NewList.
[1,2,3,4]
16> Head.
1
17> Tail.
[2,3,4]
18> [NewHead|NewTail] = Tail.
[2,3,4]
19> NewHead.
2
```

The `|` we used is named the cons operator (constructor). In fact, any list can be built with only cons and values:
我们使用的`|`操作符被称为为`cons`运算符（constructor，构造函数）。事实上，可以通过包含`cons`和值构造任意列表：

```shell
20> [1 | []].
[1]
21> [2 | [1 | []]].
[2,1]
22> [3 | [2 | [1 | []] ] ].
[3,2,1]
```

也就是说，任何列表都可以用以下公式建立：`[Term1| [Term2 | [... | [TermN]]]]...`。因此，列表可以递归地定义为一个头部在一个尾部之前，这本身就是一个头部，后面跟着多个头部。从这个意义上说，我们可以想象一个列表有点像蚯蚓：你可以把它切成两半，然后你会有两条蚯蚓。

![Two drawn worms, the first one normal with the text 'Head' and 'tail' as usual; the second has its head cut off, and under it a new 'head' is written.](../img/worm.png "Worms, like lists can be defined recursively.")

Erlang列表的构建方式有时会让不习惯类似构造函数的人感到困惑。为了帮助你熟悉这个概念，请阅读所有这些例子（提示：它们都是等效的）：

```shell
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
```

理解了这些，你就可以理解后面所说的列表推导了。

> **注：** 形式`[1 | 2]`一般被认为是“不当列表（improper list）”。当您以`[Head|Tail]`方式进行模式匹配时，不正确的列表会起作用，但无法与Erlang的标准函数（例如是`length()`）一起使用。这是因为Erlang需要匹配正确的列表形式。正确的列表以空列表作为其最后一个单元格。当声明像`[2]`这样的项时，列表会以适当的方式自动形成。因此，`[1|[2]]`就行了！不当列表虽然在语法上有效，但在用户定义的数据结构之外的用途非常有限。

```shell
25> length([1|2]).  
** exception error: bad argument
     in function  length/1
        called as length([1|2])
        *** argument 1: not a list
```

## [列表推导](#list-comprehensions)

列表推导是建立或修改列表的方法。与其他处理列表的方式相比，它们还使程序简短易懂。它基于集合记数法的思想：如果你上过集合论的数学课，或者你看过数学符号，你可能知道它是如何工作的。基本上，集合表示法告诉您如何通过指定其成员必须满足的属性来构建集合。列表推导一开始可能很难掌握，但它们值得努力。它们使代码更简洁，所以不要犹豫，尝试输入示例，直到您理解它们！

一个简单的集合例子： $\{x \in \mathbb{R}: x = x^2\}$。这个集合表达式指出，这个集合的元素属于实数集，且其值等于自身的平方。这个集合实际上等于$\{0,1\}$. 另一个简化的集合例子是：$\{x : x \gt 0\}$. 这里，我们所要指代的是所有大于0的数。

Erlang中的列表推导也是如此，是一种从其他集合构建集合的方法。给定集合`{2n : n in L}`, 和`L`是一个列表`[1,2,3,4]`的信息，Erlang实现将是：

```shell
1> [2*N || N <- [1,2,3,4]].
[2,4,6,8]
```

将数学符号与Erlang符号进行比较，没有太多变化：括号`(`，箭头的行为与`=`操作符完全相同，只是它不会引发异常。

还可以使用返回布尔值的操作向列表添加约束。如果我们想要从1到10的所有偶数，我们可以这样写：

```shell
2> [X || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].
[2,4,6,8,10]
```

其中 `X rem 2 =:= 0`检查数字是否为偶数。在实际应用中，当我们决定要对列表中的每个元素应用一个函数时，我们经常需要考虑它需要遵循的约束。例如，假设我们拥有一家餐厅。一位顾客走进来，看到我们的菜单，问他是否可以得到所有在3美元到10美元之间的商品的含税价格（假设税率是$7 \%$）。

```shell
> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
[{steak,5.99},
{beer,3.99},
{poutine,3.5},
{kitten,20.99},
{water,0.0}]
4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
[{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]
```

虽然上例中的小数不是以可读的方式四舍五入的，但你应该能明白这个意思。一般来说，Erlang中列表推导的方法是`NewList=[Expression | | Pattern<-list，Condition1，Condition2, ... ，ConditionN]`。其中，`Pattern<-List`又称为生成器表达式（Generator expression）。你可以有多个生成式表达器！

```shell
5> [X+Y || X <- [1,2], Y <- [2,3]].
[3,4,4,5]
```

这将运行操作`1+2`, `1+3`, `2+2`, `2+3`。因此，一个更通用的列表推导式可以写成：`NewList = [Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM]`。请注意，与模式匹配相结合的生成器表达式也会充当过滤器：

```eshell
6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
{montreal,storms},
{london,fog},
{paris,sun},
{boston,fog},
{vancouver,snow}]
7> FoggyPlaces = [X || {X, fog} <- Weather].
[london,boston]
```

如果列表`Weather`中的一个元素与模式不匹配（上例中就是第二个元素不为`fog`），那么它将在列表理解中被忽略，而`=`操作符将抛出一个异常。

现在还有一种基本的数据类型留给我们。这是Erlang一个令人惊讶的特性，它使解析二进制数据变得非常容易。

![Speedometer with values in binary](../img/binometer.png)

## [位句法](#bit-syntax)

大多数语言都支持操作数据，如数字（numbers）、原子(atoms)、元组(tuples)、列表(lists)、记录(records)、结构(structs)等等。但他们中的大多数在操作二进制数据时只提供了非常原始的功能。在处理二进制值时，Erlang不遗余力地提供有用的抽象，并将模式匹配提升到下一个级别。它使处理原始二进制数据变得有趣和简单（真的），因为这对于它创建的电信应用程序来说是必要的。位操作有一种独特的语法和习惯用法，乍一看可能有点奇怪，但如果你知道位和字节通常是如何工作的，这对你来说应该是有意义的。**否则你可能想跳过本章的其余部分**。

位语法将二进制数据封装在`<<`和`>>`之间，将其拆分为可读段，每个段用逗号分隔。段是二进制的位序列（不一定在字节边界上，尽管这是默认行为）。假设我们想要存储一个真实颜色的橙色像素（24位）。如果你曾经在Photoshop或CSS网页样式表中检查过颜色，你就会知道十六进制符号的格式是`#RRGGBB`。橙色在该符号中是`#F09A29`，可以在Erlang中扩展为：

```shell
1> Color = 16#F09A29.
15768105
2> Pixel = <<Color:24>>.
<<240,154,41>>
```

这基本上表示“将`#F09A29`的二进制值放在可变像素的24位空间上（8位为红色，8位为绿色，8位为蓝色）”。之后0可以将该值写入文件。虽然听起来不太可能，但一旦写入文件，在文本编辑器中打开它会得到一堆不可读的字符。当您从文件读回时，Erlang会再次将二进制文件解释为可读的`<<240,151,41>>`格式！

更有趣的是，Erlang能够与二进制文件进行模式匹配以解压缩内容：

```shell
3> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
4> <<Pix1,Pix2,Pix3,Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,64,76,32,76,
0,0,234,32,15>>
5> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
```

在表达式4中，我们试图从二进制内容中解压4个值。它抛出了一个异常，因为我们有超过4个片段，实际上我们有12个！所以我们要做的是告诉Erlang，左侧的每个变量将保存24位数据。这就是`Var:24`的意思。然后，我们可以将第一个像素进一步分解为单色值：

```shell
6> <<R:8, G:8, B:8>> = <<Pix1:24>>.
<<213,45,132>>
7> R.
213
```

那如果我从一开始就只想要第一种颜色呢？我需要一直解包所有这些值吗？哈！当然不用！Erlang引入了更多语法糖和模式匹配来帮助您：

```shell
8> <<R:8, Rest/binary>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
9> R.
213
```
不错吧？这是因为Erlang接受多种方式来描述二进制段。这些都是有效的：

> Value
> Value:Size
> Value/TypeSpecifierList
> Value:Size/TypeSpecifierList

where `Size` represents one or more of the following:
其中，`Size`可以是下列的一种或多种类型：

- **Type**
  - 可取值: `integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32`。这表示使用的二进制数据的类型。请注意，'bytes'是'binary'的缩写，'bits'是'bitstring'的缩写。如果未指定类型，Erlang将采用'integer'类型。
- **Signedness**
  - 可取值: `signed | unsigned`。只有当类型为整数（integer）时才会匹配。默认值为'unsigned'。
- **Endianness**
  - 可取值: `big | little | native`。Endianness仅在类型为integer、utf16、utf32或float时才起作用。这与系统读取二进制数据的方式有关。例如，BMP图像头格式将其文件大小保存为一个整数，存储在4个字节上。对于一个大小为72字节的文件，一个`little`的尾端系统将表示为`<<72,0,0,0>>`，而一个`big`的尾端系统将表示为`<<0,0,0,72>>`。其中一个将被解读为“72”，而另一个将被解读为“1207959552”，因此请确保使用正确的尾数。使用`native`的选项则会根据本机CPU使用little endianness或big endianness，则会在运行时进行选择。默认情况下，endianness设置为`big`。
- **Unit**
  - 可取值： `unit:Integer`, `Integer`是每个段的大小，以位为单位。允许的范围是$1\ sim 256$，对于整数、浮点和位字符串，默认设置为1，对于二进制设置为8。utf8、utf16和utf32类型不需要定义单元。大小与单位的乘积等于该段将采用的位数，并且必须能被8整除。单元大小通常用于确保字节对齐。

`TypeSpecifierList`是由`-`分割的一些属性构成的，参考以下这些例子:

```shell
10> <<X1/unsigned>> =  <<-44>>.
<<"Ô">>
11> X1.
212
12> <<X2/signed>> =  <<-44>>. 
<<"Ô">>
13> X2.
-44
14> <<X2/integer-signed-little>> =  <<-44>>.
<<"Ô">>
15> X2.
-44
16> <<N:8/unit:1>> = <<72>>.
<<"H">>
17> N.
72
18> <<N/integer>> = <<72>>.
<<"H">>
19> <<Y:4/little-unit:8>> = <<72,0,0,0>>.     
<<72,0,0,0>>
20> Y.
72
```

您可以看到，读取、存储和解释二进制数据的方法不止一种。这有点令人困惑，但仍然比使用大多数语言提供的常用工具简单得多。

Erlang中也存在标准的二进制操作（将位向左和向右移位、二进制'和（and）', '或（or）', '异或（xor）'和'非(not)'）。使用方法是调用内置函数 `bsl` (Bit Shift Left), `bsr` (Bit Shift Right), `band`, `bor`, `bxor`, 和 `bnot`。

```shell
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
```

有了这种表示法和位语法，解析和模式匹配二进制数据就轻而易举了。可以用如下代码解析TCP段：

```erlang
<<SourcePort:16, DestinationPort:16,
  AckNumber:32,
  DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
  CheckSum: 16, UrgentPointer:16,
  Payload/binary>> = SomeBinary.
```

同样的逻辑可以应用于任何二进制文件：视频编码、图像、其他协议实现等。

> **不要削足适履:**
> 与C或C++等语言相比，Erlang速度较慢。除非你是一个有耐心的人，否则用它来转换视频或图像是个坏主意。尽管二进制语法让它非常有趣，但Erlang不擅长大量的数字运算。然而，请注意，对于不需要进行数字运算的应用程序来说，Erlang仍然非常快：对事件做出反应、传递消息（通过使用非常轻量级的原子），等等。它可以在几毫秒内处理事件，因此是软实时应用程序的最佳选择。

![A string](../img/string.png)

二进制表示法还有另一个用法：位字符串。二进制字符串与列表一样属于语言的顶级实现，但在空间方面效率更高。这是因为普通列表是链表（每个字母1个“节点”），而位字符串更像是C数组。位字符串使用语法`<<"this is a bit string!">>`。与列表相比，二进制字符串的缺点是在模式匹配和操作方面相对繁琐。因此，当存储不会被太多操作的文本时，或者当空间效率是一个真正的问题时，人们倾向于使用二进制字符串。

> **注意：** 即使位字符串很轻，也应该避免使用它们来标记值。使用字符串文字来表示`{<<"temperature">>,50}`可能很有诱惑力，但在这样做时一定要使用原子。在本章之前，原子被认为在空间中只占4或8字节，不管它们有多长。通过使用它们，在将数据从一个函数复制到另一个函数或将其发送到另一台服务器上的另一个Erlang节点时，基本上不会有开销。不过，也不要因为原子更轻就把字符串全部换成原子。字符串可以被操作（切割、正则表达式等），而原子只能被比较，其他什么都不能。

## [二进制推导](#binary-comprehensions)

二进制推导是作用于位，就像列表推导作用于列表：一种使代码简短的方法。它们在Erlang世界中相对较新，就像之前的Erlang版本一样，但需要一个实现它们的模块使用特殊的编译标志才能工作。自R13B版本（此处使用的版本）以来，它们已经成为标准，可以在任何地方使用，包括外壳：

```shell
1> [ X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].    
[2,4]
```

与常规的列表理解相比，语法上唯一的变化是`<-`，它变成了`<=`，并使用二进制文件（\<\<\>\>）而不是列表（\[\]）。在本章前面，我们已经看到了一个例子，其中有许多像素的二进制值，我们使用模式匹配来获取每个像素的RGB值。这种用法很好，但在更大的结构上，它可能会变得更难阅读和维护。同样的练习也可以通过一行二进制推导来完成，它更简洁：

```shell
2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
```

将`<-`更改为`<=`让我们使用二进制流作为生成器。完整的二进制推导基本上把二进制数据变成了元组中的整数。另一种二进制推导语法允许您执行完全相反的操作：

```shell
4> << <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
```

注意，如果生成器返回二进制文件，则生成的二进制文件的元素需要明确定义的大小：

```shell
5> << <<Bin>> || Bin <- [<<3,7,5,4,7>>] >>.
** exception error: bad argument
6> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>] >>. 
<<3,7,5,4,7>>
```

如果遵守上述固定大小规则，也可以使用二进制生成器进行二进制推导：

```shell
7> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
<<4,8,6,5,8>>
```

> **注：** 在撰写本文时，二进制推导很少使用，也没有很好的文档。因此，我们介绍的内容不超过识别它们和了解其基本工作所需的内容。要从整体上理解更多位语法，请阅读[定义其规范的白皮书](http://user.it.uu.se/~pergu/papers/erlang05.pdf "Bit-level Binaries and Generalized Comprehensions in Erlang")。

[^1]: `cat` 是Linux中查看文本的命令